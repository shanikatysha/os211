---
permalink: /W08/
---

# Top 10 List of _Week 08_

1. [**Preemptive vs Non-Preemptive Scheduling**](https://www.geeksforgeeks.org/preemptive-and-non-preemptive-scheduling/)<br>
Jika dibandingkan berdasarkan CPU utilization, pada preemptive scheduling ternyata lebih tinggi dibanding non-preemptive scheduling mungkin karena preemptive scheduling lebih costly jika dibandingkan dengan non-preemptive karena harus menjaga integritas data yang dipakai bersama. Lalu pada preemptive scheduling, process dengan prioritas lebih tinggi akan dijalankan terlebih dahulu, sedangkan pada non-preemptive CPU telah dialokasikan ke suatu process. Process tersebut mempertahankan CPU hingga melepaskan CPU baik dengan menghentikan atau dengan beralih ke status menunggu.
2. [**Why use preemptive scheduling?**](https://www.sciencedirect.com/topics/engineering/preemptive-scheduling)<br>
Keuntungan utama dari preemptive scheduling adalah menyediakan mekanisme di mana pentingnya setiap task dapat didefinisikan secara tepat. Di sisi lain, memiliki kelemahan bahwa task dengan prioritas tinggi dapat membuat CPU starve (kondisi dimana sebuah proses terus-menerus menolak sumber daya yang diperlukan untuk memproses pekerjaannya) sehingga task dengan prioritas yang lebih rendah tidak akan pernah memiliki kesempatan untuk dijalankan. Ini biasanya dapat terjadi jika ada kesalahan pemrograman sehingga task dengan prioritas tinggi berjalan terus menerus tanpa harus menunggu sumber daya sistem apa pun dan tidak pernah berhenti.
3. [**Best cases for scheduling algorithm**](https://www.studytonight.com/operating-system/comparision-scheduling-algorithms)<br>
Jika proses selanjutnya pendek dan tidak perlu dijalankan dalam urutan tertentu, gunakan FCFS (first come first serve) karena tiap proses pendek dan semua proses akhirnya akan dijalankan dalam waktu dekat. Jika proses nya campuran pendek dan panjang dan perlu dijalankan semuanya, maka gunakan Round Robin karena RR tidak menyebabkan starvation dan juga memberikan waktu yang sama untuk setiap proses. Lalu jika proses merupakan campuran user dan kernel based, maka gunakan priority based scheduling karena secara umum kernel based processes punya prioritas yang lebih tinggi daripada user based processes.
4. [**Scheduling Criteria**](https://www.geeksforgeeks.org/cpu-scheduling-criteria/)<br>
Ada 5 kriteriaa yang menjadi penentu scheduling. Pertama CPU utilization yang akan menyibukkan CPU at all times. Kedua throughput yang merupakan banyaknya process yang berhasil dieksekusi per satuan waktu. Ketiga turnaround time yang merupakan jumlah waktu yang digunakan untuk mengeksekusi sebuah process. Keempat waiting time yang merupakan jumlah waktu sebuah process menunggu di ready queue. Dan kelima response time yang merupakan jumlah waktu yang ada dari mulai sebuah request diberikan hingga response pertama dihasilkan.
5. [**MLFQ CPU scheduling and why?**](https://www.geeksforgeeks.org/multilevel-feedback-queue-scheduling-mlfq-cpu-scheduling/?ref=rp)<br>
Multilevel Feedback Queue Scheduling merupakan tipe scheduling dimana prosesnya dapat berpindah queue. Why use such a complex scheduling? karena lebih flexible dibanding multilevel scheduling biasa dan juga mengurangi response time. MFQS menjalankan proses untuk kuantum waktu dan kemudian dapat mengubah prioritasnya (jika prosesnya panjang). Jadi algoritma nya belajar dari perilaku masa lalu dari proses dan kemudian memprediksi perilaku masa depan. Dengan cara ini ia mencoba menjalankan proses yang lebih pendek terlebih dahulu sehingga mengoptimalkan waktu penyelesaian.
6. [**Symmetric vs Asymmetric Multiprocessing**](https://pediaa.com/what-is-the-difference-between-symmetric-and-asymmetric-multiprocessing/)<br>
Key differencesnya adalah workflownya. Pada symmetric, semua CPU identik sehingga mereka bisa berjalan sendiri. Symmetric multiprocessing bagus jika proses sistemnya sedikit sehingga hanya perlu menggunakan shared memory untuk berkomunikasi. Sedangkan pada asymmetric, CPU nyaa berbeda-beda sehingga butuh sebuah kepala yang mengaturnya sehingga Asymmetric multiprocessing punya master-slave relationship.
7. [**Realtime Scheduling**](https://www.geeksforgeeks.org/scheduling-in-real-time-systems/)<br>
Realtime scheduling digunakan untuk sistem yang tasks nya perlu dieksekusi secepat mungkin karena berpengaruh dengan banyak hal disekitarnya (misal perlu dilakukan a sebelum b bisa dilakukan). Berdasarkan implementasi static atau dynamic, realtime scheduling dibagi menjadi 4 yaitu static table-driven, static priority-driven preemptive, dynamic planning-based, dan dynamic best effort. Yang sering digunakan pada realtime system adalah dynamic best effort, dimana deadlines lebih diutamakan daripada scheduling yang relevan sehingga saat deadline sudah lewat maka task akan dibatalkan dan tidak dijalankan.
8. [**Soft vs Hard Realtime Scheduling**](https://www.slideshare.net/knowdiff/sara-afshar-scheduling-and-resource-sharing-in-multiprocessor-realtime-systems)<br>
Yang saya sebutkan sebelumnya merupakan contoh hard realtime scheduling (berdasarkan implementasi static atau dynamic). Hard realtime scheduling lebih kaku karena ada deadline yang perlu dipenuhi, jika tidak dipenuhi akan mengakibatkan damage. Contoh dari hard realtime scheduling ada pada industrial control, automotif, dan pesawat. Sedangkan soft realtime scheduling lebih fleksibel karena deadline boleh saja tidak dipenuhi. Contoh dari soft realtime scheduling adalah TV, radio, dan streaming.
9. [**Load Balancing**](https://www.citrix.com/en-in/solutions/app-delivery-and-security/load-balancing/what-is-load-balancing.html)<br>
Load balancing didefinisikan sebagai suatu method distribusi yang efisien dari suatu jaringan atau lalu lintas aplikasi disebuah ladang server. Setiap load balancer berada di antara perangkat klien dan server backend, menerima dan kemudian mendistribusikan permintaan masuk ke server yang tersedia yang mampu memenuhinya. Load balancing pada multicore systems melakukan equalize loads diantara CPU cores, meskipun migrasi thread antar core untuk menyeimbangkan beban dapat membuat konten cache tidak valid dan oleh karena itu dapat meningkatkan memory access. times.
10. [**The real reason why we need scheduling**](https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/)<br>
Suatu typical process melibatkan baik I/O time maupun CPU time. Dalam sistem uni programming seperti MS-DOS, waktu yang dihabiskan untuk menunggu I/O terbuang percuma dan CPU kosong selama waktu tersebut. Dalam sistem multi programming, satu proses dapat menggunakan CPU sementara proses lainnya menunggu I/O. Ini hanya dapat dilakukan dengan process scheduling.
